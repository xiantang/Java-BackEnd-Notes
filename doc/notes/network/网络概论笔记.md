## 网络概论笔记

## 传输**层** 

### TCP 滑动窗口协议

#### go back N

![1559222070250](../../images/1559222070250.png)

如果是out-of-order:

* 丢弃封包
* 回复一个最大的有序的数组

就像上图如果中间一个2号封包丢失了，receiver收到3号封包的时候，是处于out-of-order的情况所以需要返回一个最大的in-order数字也就是回复1号。

#### selective repeat

 ![1559222973516](../../images/1559222973516.png)



* 发送方

如果最左边变成绿色，就可以移动窗口。

![1559223152389](../../images/1559223152389.png)

直到下一个没有收到ack的窗口

Sliding Sender Window



* 接受方

![1559223329448](../../images/1559223329448.png)

如果按照顺序接受到封包，就将in-order的所有封包滑动到下一个没有被收到的地方。

如果收到延迟/迟到的封包，就丢掉返回ACK(n)

**存在的问题**:

Windows size 最好是 seq size 的一半



#### segment

![1559224720528](../../images/1559224720528.png)



Receive window : 这个参数指的是滑动窗口的长度

S: SYN 建立连线

F: FIN 连线完成

R: RST 关闭连线

![1559226409029](../../images/1559226409029.png)

SEQ:你data中第一个byte的seq number

ACKs: 你希望下一次收到的seq number （隐含了之前都收到了）

对于没有按照顺序的封包：看开发者的实现方式。



#### TCP Round Trip Time and Timeout

timeout 应该大于RTT

使用 SampleRTT：采用取样的方式，测量时间直到收到ACK，忽略重送的封包时间。



![1559226186513](../../images/1559226186513.png)



#### 快速重传

resend segment before timer expires  

在定时器结束之前重传。



#### flow control 流量控制



![1559282483503](../../images/1559282483503.png)

流量控制指的是 sender 不要把 receiver 塞爆。

sender 能送多少的数据取决于RevWindow 的大小 

这个的大小会存储在segment的字段中。

receiver 来控制sender 送的频率，如果不想让sender 送数据那么就将传送过去的window的大小设置为0。



### 三次握手

SYN: 发起一个链接

![img](../../images/d8bf92c7906718271fdb8b0d2d5fe5b4)

1. 发送SYN为1的segment到服务器
   * 确定初始化的seq
   * 不需要data
2. 接受SYN
   * 申请buffers
   * 确定server的初始化seq
3. 客户端收到SYNACK。还要再回复一个ACK，但是这个封包可能含有数据。



#### TCP 连接管理



**客户端结束**：



![1559283754130](../../images/1559283754130.png)

 

一个connection 有两个buffer 分别是sender的和receiver的。

为什么TCP为什么是四次挥手？

因为是全双工通信的

1. 第一次挥手发送fin 表示主动方不会再继续发送报文了，但是可以发送报文
2. 第二次挥手被动方可能有相应的数据报文需要发送，需要发送ACK，告诉主动方我知道你要断开请求了
3. 第三次挥手被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。
4. 如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。

### 拥塞控制

* 定义：分组交换网络中传送分组的数目太多时，由于存储转发节点的资源有限而造成网络传输性能下降的情况。

* 现象：
  * 掉封包
  * 封包queue中，很长时间的延迟

* 解决方式：
  * 根据自己手上有的资讯进行判断
  * 根据路由器的埋点进行通知发送方

但是TCP 主要采用的是通过两端的发送方和接受方的进行判断的。



**AIMD**

首先探测网络的频宽有多大，所以他会越送越快，直到掉落分包为止。

* 每一个RTT时间就增加一个MSS(最大segment的大小) ，每个RTT 直到丢失封包
* 减少一半的**CongWin** 

![img](../../images/1234352-e9c36c1963b96e3b.webp)
$$
rate = \frac{CongWin}{RTT}    Bytes/sec
$$
**slow start**

一开始比较慢，然后指数增长 CongWin 的大小，也就是MSS的数目。

当连接开始的时候，提升每个 RTT 发送的 CongWin 的大小。

- 收到ACK的时候提升两倍CongWin的大小，也是就是两倍的segment的数目。



推断丢包

- 收到3个重复的ACK
  - CongWin cut 一半
  - 线性增加CongWin的大小
- 发生timeout
  - CongWin 替换为 1MSS
  - window 先指数增长
  - 到达临界值的时候线性增长

![img](../../images/1234352-2738b3eb14207b1c.webp)



#### 总结

* 双向的连接
* 每个seq的单位是1byte
* 根据流量控制和拥塞控制来决定窗口的大小





##  网络层

### 网络层最重要的两个服务



* 转发:将一个封包从一个路由器转发到最合适的出口路由器
* 路由:决定你的封包的起点到终点的路径  



### 无连接的服务

#### Datagram networks

* 不需要建立连接
* 不需要记录之前的路径
* 根据查表走路径



**转发表**：

前缀匹配: 只要知道前面的bit数目，就可以知道对应的Link interface

![1559307942030](../../images/1559307942030.png)

当好几个项都匹配的时候，去到那个最长的匹配的接口。

#### IP datagram format

![1559310072992](../../images/1559310072992.png)



* offset:封包对于原来封包所在的位置
* 16-bit identifien:确定是哪个segment



#### Subnets

可以直接沟通不通过其他路由器

* subnet part(高位bit)
* host part(低位bit)



### IPv6

#### Header(Cont)

![1559741999036](../../images/1559741999036.png)

* Checksum: 从IPV4 中去掉了
* ICMPv6: 封包太大的异常 群播

#### 转移 IPv4->IPv6

隧道:IPv6的封包放到IPv4里面

![1559742437450](../../images/1559742437450.png)

其实就是将V6的封包包在V4中而已

![1559742541710](../../images/1559742541710.png)

