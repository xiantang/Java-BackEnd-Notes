# TODO
* ASM框架
* 程序计数器，本地方法区
* 字节码增强
* 类加载机制，双亲委派模型
* JVM的内存模型  
* 内存泄漏和内存溢出
* java的垃圾回收机制   
* 讲一下JVM的内存分区 
* 《深入理解JVM虚拟机》垃圾回收原理 
* Java的逻辑分区 
* 方法区啥的?一个成员变量存在哪里?如果是局部变量是一个对象的引用呢?存在哪里?



## 堆和栈的区别



| 类型     | 堆                                        | 栈                 |
| -------- | ----------------------------------------- | ------------------ |
| 功能     | 堆存储Java对象(成员变量,局部变量，类变量) | 存储局部变量和方法 |
| 共享性   | 线程共有                                  | 线程私有           |
| 异常错误 | StackOverFlowError                        | OutOfMemoryError   |

- 功能不同
      * 堆存储Java中的对象（成员变量，局部变量，类变量）。
          * 栈用来存储局部变量（方法内部的变量）和方法。
- 共享性不同
  - 栈的内存是线程私有的。(方法相关的当然私有啊！！)
  - 堆的内存是线程共有的。
- 异常错误不同
  - 栈空间不足：java.lang.StackOverFlowError。 经典！
  - 堆空间不足：java.lang.OutOfMemoryError。对象存满了 -->

### 栈的组成

栈三部分:

- 局部变量区

  - 结构:以一个字长为单位，从0开始计数的数组。
  - 类型为short、byte和char会被转换成为int
    long和double占据两个连续的元素。
  - 实例方法只是多了一个隐藏的this。
  - 获取数据直接取索引。

- 操作数栈

  - 和局部变量一样，也是字长为1的数组，不是通过索引是用出栈和入栈来决定的。还记得迪杰斯特拉吗？！
    ![](https://iamjohnnyzhuang.github.io/public/upload/4.png)

- 帧数据区

  - Java栈帧还需要一些数据来支持常量池的解析，正常方法的返回。
  - 处理方法的正常结束和异常终止。通过return来正常结束的话，就弹出当前的栈帧，恢复发起调用方法的栈。如果方法有返回值JVM就会将返回值压入调用方法的操作数栈中。
  - 处理异常:保存了一个对此方法异常引用表的引用。

- 栈的整个结构

  ```java
  public class Main {
  public static void addAndPrint(){
      double result = addTwoTypes(1, 88.88);
      System.out.println(result);
  }
  
  public static double addTwoTypes(int i, double d) {
      return i + d;
      }
  }
  ```

  过程快照：
  ![](https://iamjohnnyzhuang.github.io/public/upload/5.png)

如果是方法中的局部变量就存储在堆中。

### 堆

当一颗二叉树的每个节点都大于等于它的两个子节点时，称作堆有序。
用执政表示一个二叉树的话就是一个完全二叉树。

- 由上到下的堆有序:
  - 上浮:只要记住位置k节点的父亲节点是位置k/2
    - 插入元素：将新元素上浮到适合位置
  - 下沉:
    - 删除最大元素：从数组顶端删除最大元素，选择数组最后节点。



### 方法区

是一个各个线程共享的内存区域，用于存储已经被虚拟机加载的类信息，常量，静态变量，及时编译器编译后的代码等数据。别名`Non-Heap`，目的是与Java堆区分开来。

### 运行时常量池

运行时候常量池是方法区的一部分，Class文件除了类的版本，字段，方法等描述信息，还有一个信息是(Constant Pool Table),用于存放字面量和符号引用，这部分将在类加载后进入方法区的运行常量池中。 
类的信息，方法名，方法参数信息。

## GC

`finalize()`：用来发现对象是否存在有没有没有被清除的部分。一旦垃圾回收器准备好释放对象占用的空间时，首先调用这个方法，并且在下一次垃圾回收动作发生时，才会真正回收内存。

基于DFS的垃圾回收技术：对于活的对象，一定可以从堆栈或者静态存储区中找到它的引用，然后遍历找到对象，在寻找对象的引用，往复如此，就能得到所有活的对象。

- "停止"----"复制":暂停程序运行，将存活对象复制到另外一个堆，没有复制的都是垃圾。
  搬运的同时，所有指向对象的引用都必须修正，位于 堆和静态存储区的引用可以直接被修正。
  - 需要两个堆，按需从堆分配几块较大的内存，复制动作发生在大块内存之间。
  - 程序稳定没有垃圾时， 切换到"标记 ----清扫"模式，在垃圾少的时候速度很快。
- "标记 ----清扫":DFS遍历所有活的对象，并设置标记， 结束后，没有标记的对象释放， 但是剩下的堆空间是不连续的 ，所以得重新整理对象。

Java虚拟机会监控垃圾回收器的效率， 如果效率低就采用"标记 ----清扫"，如果内存中碎片较多就会采用"停止 ---- 复制"，这样的自适应策略。
    

## 对象存在的周期

### 对象创建

1. 首先先再常量池定位某个类的符号引用
2. 内存所需要的大小需要类加载完成后才能知道 
3. 对对象必要设置

### 垃圾回收器的工作原理

垃圾回收器工作时一面回收空间，一面使堆中的对象紧凑排列，这样堆指针就能够更容易的移动到传送带开始的地方。

## 反射

**Java 反射机制**：在程序运行的时候，对于任意的一个类，都能够知道这个类的所有属性和方法，对于任意一个对象可以调用它的任意属性和方法这种动态获取信息以及动态调用对象的方法的功能叫做Java反射(reflect)。



## Java 热部署原理

1、热部署是什么？

对于Java应用程序来说，热部署就是在运行时更新Java类文件。

2、热部署有什么用？

可以不重启应用的情况下，更新应用。举个例子，就像电脑可以在不重启的情况下，更换U盘。

OSGI也正是因为它的模块化和热部署，才显得热门。

3、热部署的原理是什么？

想要知道热部署的原理，必须要了解java类的加载过程。一个java类文件到虚拟机里的对象，要经过如下过程。

![img](../../images/030931301899477-1559111854402-1559111856420.png)

首先通过java编译器，将java文件编译成class字节码，类加载器读取class字节码，再将类转化为实例，对实例newInstance就可以生成对象。

类加载器ClassLoader功能，也就是将class字节码转换到类的实例。

在java应用中，所有的实例都是由类加载器，加载而来。

一般在系统中，类的加载都是由系统自带的类加载器完成，而且对于同一个全限定名的java类（如com.csiar.soc.HelloWorld），只能被加载一次，而且无法被卸载。

这个时候问题就来了，如果我们希望将java类卸载，并且替换更新版本的java类，该怎么做呢？

​     既然在类加载器中，java类只能被加载一次，并且无法卸载。那是不是可以直接把类加载器给换了？答案是可以的，我们可以自定义类加载器，并重写ClassLoader的findClass方法。想要实现热部署可以分以下三个步骤：

1、销毁该自定义ClassLoader

2、更新class类文件

3、创建新的ClassLoader去加载更新后的class类文件。

示例代码如下：



```java
package com.csair.soc.hotswap;

import java.io.IOException;
import java.io.InputStream;
/**
 * 自定义类加载器，并override findClass方法
 */
public class MyClassLoader extends ClassLoader{
     @Override
     public Class<?> findClass(String name) throws ClassNotFoundException{
            try{
                String fileName = name.substring(name.lastIndexOf("." )+1) + ".class" ;
                InputStream is = this.getClass().getResourceAsStream(fileName);
                 byte[] b = new byte[is.available()];
                is.read(b);
                 return defineClass(name, b, 0, b. length);
           } catch(IOException e){
                 throw new ClassNotFoundException(name);
           }
     }
}
```

需要更新的类文件：

```java
package com.csair.soc.hotswap;
public class HelloWorld {
     public void say(){
           System. out.println( "Hello World V1");
     }
}
```

在工程的根目录下，生成V2版本的HelloWorld.class,内容如下。

```java
package com.csair.soc.hotswap;
public class HelloWorld {
      public void say(){
           System. out.println( "Hello World V2");
     }
}
```

测试主程序

```java
package com.csair.soc.hotswap;

import java.io.File;
import java.lang.reflect.Method;

public class Hotswap {
     public static void main(String[] args) throws Exception {
            loadHelloWorld();
            // 回收资源,释放HelloWorld.class文件，使之可以被替换
           System. gc();
           Thread. sleep(1000);// 等待资源被回收
           File fileV2 = new File( "HelloWorld.class");
           File fileV1 = new File(
                      "bin\\com\\csair\\soc\\hotswap\\HelloWorld.class" );
           fileV1.delete(); //删除V1版本
           fileV2.renameTo(fileV1); //更新V2版本
           System. out.println( "Update success!");
            loadHelloWorld();
     }

     public static void loadHelloWorld() throws Exception {
           MyClassLoader myLoader = new MyClassLoader(); //自定义类加载器
           Class<?> class1 = myLoader
                     .findClass( "com.csair.soc.hotswap.HelloWorld");//类实例
           Object obj1 = class1.newInstance(); //生成新的对象
           Method method = class1.getMethod( "say");
           method.invoke(obj1); //执行方法say
           System. out.println(obj1.getClass()); //对象
           System. out.println(obj1.getClass().getClassLoader()); //对象的类加载器
     }
}
```

输出结果：

Hello World V1

class com.csair.soc.hotswap.HelloWorld

com.csair.soc.hotswap.MyClassLoader@bfc8e0

Update success!

Hello World V2

class com.csair.soc.hotswap.HelloWorld

com.csair.soc.hotswap.MyClassLoader@860d49

根据结果可以看到，在没有重启应用的情况下，成功的更新了HelloWorld类。

以上只是热部署的最简单的原理实践，实际情况会复杂的多。OSGI的最关键理念就是应用模块（bundle）化，对于每一个bundle,都有其自己的类加载器，当需要更新bundle时，把bundle和它的类加载器一起替换掉，就可以实现模块的热替换。



### 参考资料

深入理解java虚拟机

深入探讨 Java 类加载器 http://www.ibm.com/developerworks/cn/java/j-lo-classloader/b

# Jvm

## Java 技术体系

* Java 程序设计语言
* 各种平台上的Java 虚拟机
* Java API 类库 
* 来自商业机构和开源社区的第三方Java类库

Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK（Java
Development Kit）

Java API类库中的Java
SE API子集 [1] 和Java虚拟机这两部分统称为JRE（Java Runtime Environment）

![1562206136776](../../images/1562206136776.png)

* Java ME（Micro Edition）：支持Java程序运行在移动终端（手机、PDA）上的平台，对
  Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME。
* Java SE（Standard Edition）：支持面向桌面级应用（如Windows下的应用程序）的Java
  平台，提供了完整的Java核心API，这个版本以前称为J2SE。
* Java EE（Enterprise Edition）：支持使用多层架构的企业应用（如ERP、CRM应用）的
  Java平台，除了提供Java SE API外，还对其做了大量的扩充 [3] 并提供了相关的部署支持，这
  个版本以前称为J2EE。

混合语言：

多语言混合编程正成为主流，每种语言都可以针
对自己擅长的方面更好地解决问题。试想一下，在一个项目之中，并行处理用Clojure语言编
写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完
成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像
使用自己语言的原生API一样方便 [1] ，因为它们最终都运行在一个虚拟机之上。

64 位虚拟机：

Java程序运行在64位虚拟机上需要付出比较大的额外代价：首先是内
存问题，由于指针膨胀和各种数据类型对齐补白的原因，运行于64位系统上的Java应用需要
消耗更多的内存，通常要比32位系统额外增加10%～30%的内存消耗；

普通对象指针压缩:

（-XX：+UseCompressedOops，这个参数不建议显式设
置，建议维持默认由虚拟机的Ergonomics机制自动开启）

### Java 内存区域 与 内存溢出异常

![1562207649814](../../images/1562207649814.png)

### 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线
程所执行的字节码的行号指示器。

线程私有

### 虚拟机栈

Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的
生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时
都会创建一个栈帧（Stack Frame [1] ）用于存储局部变量表、操作数栈、动态链接、方法出口
等信息。



#### 局部变量表

局部变量表存放了编译期可知的各种基本数据类型：

boolean、byte、char、short、int、
float、long、double，returnAddress

其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据
类型只占用1个。

### 本地方法栈

本地方法栈则为虚拟机使用到的Native方法服务。

### Java 堆

Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。
Java堆是被所有线程共享的一块内存区域。

新生代/老年代

再细致一点的有
Eden空间、From Survivor空间、To Survivor空间等。

从内存分配的角度来看，线程共享的
Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。

### 方法区

被加载的类信息

常量 

静态变量

即时编译器编译后的代码数据

HotSpot 虚拟机设计团队选择把GC分代收集扩展至方法区

1.7 把放在永久代的字符串常量池移除

##### 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版
本、字段、方法、接口等描述信息外。

String 的 intern() 方法可以将运行期间的新的常量也放入池中

JDK 1.7 开始逐步去永久代

### 直接内存

虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。

NIO 可以通过Native 函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。（NIO 为什么这么快）

## HotSpot 虚拟机对象揭秘

1. 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一
   个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。
2. 执行类加载过程，双亲委派
3. 分配内存，指针碰撞或者是空闲列表 Free List 看垃圾收集器
   1. 移动指针并不线程安全  1.CAS配上失败重试   2.每个线程在Java堆中预先分配一小块内
      存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）
4. 虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）
5. 虚拟机要对对象进行必要的设置

7/8 69

### 对象内存布局

#### 对象头

* 哈希码
* GC 分代年龄
* 锁状态标志
* 线程持有的锁
* 偏向线程的ID/偏向时间戳

在64 和32 位系统分别是 64bit 和32 bit

在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，而在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容见表。

![1562553013374](../../images/1562553013374.png)

#### 对象访问定位

Java 程序通过栈上的reference 数据来操作堆上的具体数据

使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息：

![1562554322901](../../images/1562554322901.png)

如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址

![1562554585495](../../images/1562554585495.png)

使用句柄的好处是在对象被移动的时候只会改变实例的数据指针

![1562554803379](../../images/1562554803379.png)

接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，
由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成
本。

## 垃圾收集器与内存分配策略

Java 不选用引用计数是因为它很难解决对象之间相互循环引用的问题。

### 可达性分析算法

这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连
（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如图3-1所示，对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。

![1562575957668](../../images/1562575957668.png)

在Java语言中，可作为GC Roots的对象包括下面几种：

* 虚拟机栈（栈帧中的本地变量表）中引用的对象。
* 方法区中类静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中JNI（即一般说的Native方法）引用的对象

### 生存还是死亡

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

如果这个对象有必要执行finalize() 方法，那么这个对象会放置再一个叫做F-Queue 的队列，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。

finalize()方法只会被系统自动调用一次，一次逃脱成功，之后就会失败。

### 是否需要回收方法区

方法区（hotspot中的永久代）一般垃圾回收的效率远低于新生代。

永久代回收的主要是两部分内容：

* 废弃常量
  * 进入常量池，当前系统没有任何String对象引用这个常量，也没有地方引用这个字面量，就会被清理出常量池。
* 无用的类（全部满足才算）
  * 该类的所有实例都已经被回收
  * 加载该类的ClassLoader 已经被回收
  * 该类对应的java.lang.Class对象没有任何地方被引用，，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了`-Xnoclassgc`参数进行控制，还可以使用`-verbose：class`以及`-XX：+TraceClassLoading`、`-XX：
+TraceClassUnLoading`查看类加载和卸载信息，其中`-verbose：class`和`-XX：+TraceClassLoading`可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持

### 垃圾收集算法

#### 标记-清除

首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。

主要需要解决两个问题：

* 效率问题：标记和清除效率都不高
* 空间问题：内存碎片

#### 复制算法

把内存分为两个空间一个是From空间，一个是To空间，对象一开始只在From空间分配，To空间是空闲的。GC时把存活的对象从From空间复制粘贴到To空间，之后把To空间变成新的From空间，原来的From空间变成To空间。回收前后对比下图所示：

![img](https://pic3.zhimg.com/80/v2-827a460746eeede7f83a43877a74c2a2_hd.jpg)

IBM 研究表明，新生对象98%都是“朝生夕死”，所以并不需要按照`1:1`的比例来划分内存空间。

当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是`8:1`，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行`分配担保（Handle Promotion）。`

### 标记整理

针对复制算法的缺陷，效率会变低，如果内存中的对象100%存活的情况，所以老年代不能直接使用这个算法。

标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

### 分代收集

对象存活周期的不同将内存划分为几块。一般是把Java堆
分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

* 新生代 大批对象死去，少量存活，使用复制
* 老年代 存活概率高，没有额外的空间进行分配担保，使用标记-清理/标记-整理

### HotSpot 算法实现

可达性分析找引用链主要全局性的引用（例如常量或类静态属性）与执行上下文（栈帧中的本地变量表）

GC 停顿，这项分析工作必须在一个能确保一致性的快照中进行，不能出现引用关系还在不断变化的情况。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为`“Stop The World”`）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。

所以当执行系统停顿下来后，并不需要一个不漏地检查完所有
执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的。

#### 安全点（Safepoint）

OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。

只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint）。

#### 安全区域（Safe Region）

安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。

### 垃圾回收器 JDK 1.7

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。



![1562822700914](../../images/1562822700914.png)

展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。

#### Serial（串行） 收集器

JDK 1.3.1 之前新生代收集器的唯一选择

单线程收集器

* 不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作
* 进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。

![1562823044829](D:\project\Java-BackEnd-Notes\doc\images\1562823044829.png)

JDK 1.3->1.7 HotSpot虚拟机开发团队为消除或者减少工
作线程因内存回收而导致停顿的努力一直在进行着

现在为止还是Client 模式下默认的新生代收集器。

他有着简单而高效（与其他收集器的单线程比），对于单CPU 环境，并且没有上下文切换的开销，专心做垃圾回收。

在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很
大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。

#### ParNew 收集器

ParNew收集器其实就是Serial收集器的多线程版本。

![1562823527614](../../images/1562823527614.png)

* 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
* 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。

#### CMS 收集器

Concurent Mark Sweep

四个步骤:

* 初始标记
* 并发标记
* 重新标记
* 并发清除

初始标记、重新标记这两个步骤仍然需要“Stop The World”。

初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing的过程。

重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

![1562844211568](../../images/1562844211568.png)

缺点：

* CPU 资源非常敏感
* 无法处理浮动垃圾
* 基于 标记 - 清除算法实现的收集器



#### G1 收集器

G1是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。



特点：

* 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。

* 分代收集：与其他收集器一样，分代的概念在G1 中依然保留，不需要其他收集器就能独立管理一整个GC堆。
* 空间整合：G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。

* 可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

G1  收集器将整个Java 堆划分为多个大小相等的Region，新生代和老年代不再物理隔离，都是一部分Region 的集合。

* 初始标记
* 并发标记
* 最终标记
* 筛选标记

### 内存分配策略

#### 对象优先在Eden分配

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

* 新生代GC（Minor GC）：发生再新生代的垃圾回收动作，MinorGC 非常频繁
* 老年代GC （Major GC/Full GC):发生在老年代的GC。



#### 大对象进入老年代

所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。

虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。



### 虚拟机性能监控与故障处理工具

* jps 显示HotSpot 虚拟机进程

* jstat 收集虚机各方面运行数据
  * jstat-gcutil 2764 
  * ![1562899230830](../../images/1562899230830.png)
* jstack ：命令用于生成虚拟机当前时刻的线程快照
* jmap：命令用于生成堆转储快照，也可以添加-XX：+HeapDumpOnOutOfMemoryError 
* jhat : 与jmap搭配使用

### 类加载机制

![1562900579891](../../images/1562900579891.png)

五种情况必须对类进行初始化：

* 使用new关键字实例化对象的时候、读取或设置一个类的静态字段以及调用一个类的静态方法的时候。
* 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
* 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
* 当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。
* 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄
  所对应的类没有进行过初始化，则需要先触发其初始化。

#### 加载

* 通过一个类的全限定名来获取定义此类的二进制字节流。
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
* 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

#### 类加载器

比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等

被破坏:

* 即JDK 1.2发布之前。
* 基础的类调用用户类的api：线程上下文类加载，父类区请求子类加载器加载的动作，逆向使用类加载器。
* 用户追求动态性 每一个程序模块（OSGi中称为Bundle）都有一个自己的类 加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换

### Java 内存模型

基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）

乱序执行分为处理器级别和编译器级别

![1562932004995](../../images/1562932004995.png)

所有变量在主内存。

每条线程有他的工作内存（可以与高速处理器缓存类比）保存了变量在主存的拷贝。线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的变量。



#### 内存间的交互

![1562932437042](../../images/1562932437042.png)

volatile 对于非原子的操作存在问题。

对于并发的一个自增race操作 在java 字节码中是这样的

![1562932992998](../../images/1562932992998.png)

其实在getstatic 的那个瞬间所得到的数是正确的，但是执行 下面两个指令的时候，其他线程可能已经把race的值加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存之中。

由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。

* 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
* 变量不需要与其他的状态变量共同参与不变约束。

使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。

因为CPU 采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理，这样的指令重排。所以在最后添加一个，lock addl＄0x0，（%esp） 指的是把修改同步到内存，就意味着之前的操作都已经执行完成，这样就形成了“指令重排不越过内存屏障“





在爱奇艺做了什么？ 排障 

负载均衡算法 怎么 把流量打均匀 session（redis） 

一个对象的生命周期

JVM 是怎么创建一个线程的

两台机子最多能建立多少个TCP链接

为什么要有三次握手和四次挥手 

三次握手怎么匹配 sq number

布隆过滤器怎么调参

布隆过滤器的哈希函数是自己实现的吗? 不是

为什么wait time 是2MSL 如果是10MSL 20MSL 会怎么样

MSL 是怎么算出来的？

NIO 的核心理念是什么？为什么叫NIO 

NIO 多路复用select()  epoll() 演进流程  同步到异步

原子类线程调度的关系

JVM 内存模型（你给我说清楚 是JVM 还是JMM)

一定要有老年代和新生代吗 没有没关系吗？

JMM 工作内存 和 主内存主要是什么 

JMM 最重要的准则是什么 happens before ？

JVM 运行时候数据模型是怎么样的?

老年代垃圾回收算法

happens before 原则运用

实现热加载主要解决了什么问题 热加载 我说重新new 类加载器 他好像不满意？？

双亲委派怎么实现的 解决了什么问题 

解决碎片 不怎么了解垃圾回收器？ 解决碎片主要用什么收集器？

反转链表

![1563091010474](../../images/1563091010474.png)