* ~~负载均衡算法维持会话使用的算法 7层~~
* ~~nio 中 在 unix 函数用了什么？ epoll ？~~
* ~~cas 自旋的好处？~~
* ~~线程池如何运作？他的参数是什么？阻塞队列的作用是什么？为什么要有阻塞队列~~
* ~~nio 多路复用是同步还是异步的?~~
* mysql 悲观锁乐观锁 用sql 怎么写
* 线程池在请求来了的时候是怎么创建线程和利用请求队列的？
* mysql 事务是怎么实现的?
* HashMap 线程不安全的情况? 1.8 1.7 分析
* 聚集索引与非聚集索引的区别
* mysql 默认的隔离级别
* volatile 的实现 内存屏障的实现 指令重排序的应用场景
* mysql 的两个引擎的区别  性能 差多少  为什么？
* chm 怎么计算分段的数量 构造函数里面有 忘了
* 项目中有没有用到过行锁，怎么实现的（四种锁）？
* 死锁发生的条件，对锁超时，如果遇到抢占锁怎么办？



## LVS 持久性连接

从用户端来解释，就是当一个用户第一次访问被负载均衡代理到后端服务器A并登录后，服务器A上保留了用户的登录信息；当用户再次发送请求时，根据负载均衡策略可能被代理到后端不同的服务器，例如服务器B，由于这台服务器B没有用户的登录信息，所以导致用户需要重新登录。这对用户来说是不可忍受的。所以，在实施负载均衡的时候，我们必须考虑Session的问题。

### 问题出在哪里？ 如何处理？

* 会话保持（案例：Nginx、Haproxy）
* 会话复制（案例：Tomcat）
* 会话共享（案例：Memcached、Redis）

我们这里主要讲的是 会话保持的方式，这个方式也主要是从负载均衡这一层进行解决。

首先讲两个十分通用的方式吧！

### 会话保持



#### IP_HASH

每个请求按照访问的ip的Hash结果进行分配，这样每个访客可以访问同一个后端服务器，达到保持Session的方法。

```
upstream bakend {
   ip_hash;
   server192.168.0.11:80;
   server192.168.0.12:80;
 }
```

#### Cookie 识别

也就是Haproxy在用户第一次访问的后在用户浏览器插入了一个Cookie，用户下一次访问的时候浏览器就会带上这个Cookie给Haproxy，Haproxy进行识别

`配置指令:cookie  SESSION_COOKIE  insert indirect nocache`

配置例子如下：

```
cookie SERVERID insert indirect nocache
server web01 192.168.56.11:8080 check cookie web01
server web02 192.168.56.12:8080 check cookie web02
```

其次就是一个三方模块 nginx-sticky-module

注意：cookie需要浏览器支持，且有时候会泄露数据

#### nginx-sticky-module

工作原理:

* Sticky是nginx的一个模块，它是基于cookie的一种nginx的负载均衡解决方案，通过分发和识别cookie，来使同一个客户端的请求落在同一台服务器上，默认标识名为route

1. 客户端首次发起访问请求，nginx接收后，发现请求头没有cookie，则以轮询方式将请求分发给后端服务器。
2. 后端服务器处理完请求，将响应数据返回给nginx。
3. 此时nginx生成带route的cookie，返回给客户端。route的值与后端服务器对应，可能是明文，也可能是md5、sha1等Hash值
4. 客户端接收请求，并保存带route的cookie。
5. 当客户端下一次发送请求时，会带上route，nginx根据接收到的cookie中的route值，转发给对应的后端服务器。

![1562398604770](../../../images/1562398604770.png)

无论如何刷新你都会发现这个 route 不会改变。

### 会话共享

既然会话保持和会话复制都不完美，那么我们为什么不把Session放在一个统一的地方呢，这样集群中的所有节点都在一个地方进行Session的存取就可以解决问题。

​    **Session存放到哪里？**

对于Session来说，肯定是频繁使用的，虽然你可以把它存放在数据库中，但是真正生产环境中我更推荐存放在性能更快的分布式KV数据中，例如：Memcached和Redis。

## nio 中 在 unix 函数用了什么？ epoll ？

select，poll，epoll都是IO多路复用的机制。

I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。

但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

### select()

`int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);`

select 描述符分为3类 writefds、readfds、和exceptfds

函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。

优点：select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。

缺点 ： select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024。



### 对于NIO 

执行selector.select()方法，poll0 函数把指向socket 句柄和事件的内存地址传给底层函数。

1. 如果之前没有发生事件，程序就阻塞在select处，当然不会一直阻塞，因为epoll在timeout时间内如果没有事件，也会返回。
2. 一旦有对应的事件发生，poll0方法就会返回。
3. 统计有事件发生的SelectionKey数量，并把符合条件发生事件的SelectionKey添加到selectedKeys哈希表中，提供给后续使用。

* 在早期的JDK1.4和1.5 update10版本之前，Selector基于select/poll模型实现
* 在JDK1.5 update10和linux core2.6以上版本，sun优化了Selctor的实现，底层使用epoll替换了select/poll。


### 线程如何运作呢？

![img](../../images/b17448d868e81c5a53c419a70d3fe59e)

### 乐观锁 

https://juejin.im/post/5c9b1b7df265da60e21c0b57#heading-8

乐观锁 MVCC 多版本控制 

### 隔离级别

 `MySQL`是一个服务器／客户端架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（`Session`）。我们可以同时在不同的会话里输入各种语句，这些语句可以作为事务的一部分进行处理。不同的会话可以同时发送请求，也就是说服务器可能同时在处理多个事务，这样子就会导致不同的事务可能同时访问到相同的记录。我们前边说过事务有一个特性称之为`隔离性`，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样子的话对性能影响太大，所以设计数据库的大叔提出了各种`隔离级别`，来最大限度的提升系统并发处理事务的能力，但是这也是以牺牲一定的`隔离性`来达到的。

### 未提交读:

一个事务读到了另一个未提交事务修改过的数据

![image_1d6t5hhamcd61qkjk9v1ag8171o7u.png-95.6kB](../../images/169bde35552fb49c)

如果session B 进行回滚，那么session A 就会读到一个存在的数据。

就是`脏读`。

### 已提交读

一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。

![image_1d6t64lgg1j4mtp818f61n09t6l8o.png-133.1kB](../../images/169bde3557ef6578)

对于某个处在在`已提交读`隔离级别下的事务来说，只要其他事务修改了某个数据的值，并且之后提交了，那么该事务就会读到该数据的最新值，比方说：

![image_1d6urs4l0g799959e1jsj1cvqai.png-170.6kB](../../images/169bde356084eb69)

我们在`Session B`中提交了几个隐式事务，这些事务都修改了`id`为`1`的记录的列c的值，每次事务提交之后，`Session A`中的事务都可以查看到最新的值。这种现象也被称之为`不可重复读`。

### 可重复读

在一些业务场景中，一个事务只能读到另一个已经提交的事务修改过的数据，但是第一次读过某条记录后，即使其他事务修改了该记录的值并且提交，该事务之后再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据。那么这种`隔离级别`就称之为`可重复读`（英文名：`REPEATABLE READ`），如图所示：

![image_1d6useq9aagi9981sm21b011dt4bf.png-171.1kB](../../images/169bde35523d0ae5)
从图中可以看出来，`Session A`中的事务在第一次读取`id`为`1`的记录时，列`c`的值为`'刘备'`，之后虽然`Session B`中隐式提交了多个事务，每个事务都修改了这条记录，但是`Session A`中的事务读到的列`c`的值仍为`'刘备'`，与第一次读取的值是相同的。

### 串行化

![image_1d6uu0sk41213olj102t1tsa10o9ds.png-122.9kB](../../images/169bde3556310c02)

如图所示，当`Session B`中的事务更新了`id`为`1`的记录后，之后`Session A`中的事务再去访问这条记录时就被卡住了，直到`Session B`中的事务提交之后，`Session A`中的事务才可以获取到查询结果。

### 事务的实现

### 版本链

对于使用`InnoDB`存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（`row_id`并不是必要的，我们创建的表中有主键或者非NULL唯一键时都不会包含`row_id`列）：

* trx_id: 每次对某条聚簇索引记录改变时候，都会把对应事务赋值给trx_id隐藏列。
* roll_pointer:每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到`undo日志`中。

![image_1d6vemvvn1db6h431ekvsp158m19.png-15kB](../../images/169bf19851d3dce6-1562739070773)

每次对记录进行改动，都会记录一条`undo日志`，每条`undo日志`也都有一个`roll_pointer`属性（`INSERT`操作对应的`undo日志`没有该属性，因为该记录并没有更早的版本），可以将这些`undo日志`都连起来，串成一个链表，所以现在的情况就像下图一样：

![image_1d6vfrv111j4guetptcts1qgp40.png-57.1kB](../../images/169bf198524e1b34)

* 对于未提交读只要获取最新一条就行了

对于提交读和重复读采用ReadView:

把当前活跃的id放到一个列表中命名为 m_ids

* 如果被访问版本的`trx_id`属性值小于`m_ids`列表中最小的事务id，表明生成该版本的事务在生成`ReadView`前已经提交，所以该版本可以被当前事务访问。

* 如果被访问版本的`trx_id`属性值大于`m_ids`列表中最大的事务id，表明生成该版本的事务在生成`ReadView`后才生成，所以该版本不可以被当前事务访问。

* 如果被访问版本的`trx_id`属性值在`m_ids`列表中最大的事务id和最小事务id之间，那就需要判断一下`trx_id`属性值是不是在`m_ids`列表中，如果在，说明创建`ReadView`时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建`ReadView`时生成该版本的事务已经被提交，该版本可以被访问。

提交读是在每次selelct的时候生成一个ReadView

可重复读是在第一次select的时候生成一个ReadView，之后复用

### HashMap 线程不安全的情况? 1.8 1.7 分析

