* ~~负载均衡算法维持会话使用的算法 7层~~
* nio 中 在 unix 函数用了什么？ epoll ？
* cas 自旋的好处？
* 线程池如何运作？他的参数是什么？阻塞队列的作用是什么？为什么要有阻塞队列
* nio 多路复用是同步还是异步的?
* mysql 悲观锁乐观锁 用sql 怎么写
* 线程池在请求来了的时候是怎么创建线程和利用请求队列的？
* mysql 事务是怎么实现的?
* HashMap 线程不安全的情况? 1.8 1.7 分析
* 聚集索引与非聚集索引的区别
* mysql 默认的隔离级别
* volatile 的实现 内存屏障的实现 指令重排序的应用场景
* mysql 的两个引擎的区别  性能 差多少  为什么？
* chm 怎么计算分段的数量 构造函数里面有 忘了
* 项目中有没有用到过行锁，怎么实现的（四种锁）？
* 死锁发生的条件，对锁超时，如果遇到抢占锁怎么办？



## LVS 持久性连接

从用户端来解释，就是当一个用户第一次访问被负载均衡代理到后端服务器A并登录后，服务器A上保留了用户的登录信息；当用户再次发送请求时，根据负载均衡策略可能被代理到后端不同的服务器，例如服务器B，由于这台服务器B没有用户的登录信息，所以导致用户需要重新登录。这对用户来说是不可忍受的。所以，在实施负载均衡的时候，我们必须考虑Session的问题。

### 问题出在哪里？ 如何处理？

* 会话保持（案例：Nginx、Haproxy）
* 会话复制（案例：Tomcat）
* 会话共享（案例：Memcached、Redis）

我们这里主要讲的是 会话保持的方式，这个方式也主要是从负载均衡这一层进行解决。

首先讲两个十分通用的方式吧！

### 会话保持



#### IP_HASH

每个请求按照访问的ip的Hash结果进行分配，这样每个访客可以访问同一个后端服务器，达到保持Session的方法。

```
upstream bakend {
   ip_hash;
   server192.168.0.11:80;
   server192.168.0.12:80;
 }
```

#### Cookie 识别

也就是Haproxy在用户第一次访问的后在用户浏览器插入了一个Cookie，用户下一次访问的时候浏览器就会带上这个Cookie给Haproxy，Haproxy进行识别

`配置指令:cookie  SESSION_COOKIE  insert indirect nocache`

配置例子如下：

```
cookie SERVERID insert indirect nocache
server web01 192.168.56.11:8080 check cookie web01
server web02 192.168.56.12:8080 check cookie web02
```

其次就是一个三方模块 nginx-sticky-module

注意：cookie需要浏览器支持，且有时候会泄露数据

#### nginx-sticky-module

工作原理:

* Sticky是nginx的一个模块，它是基于cookie的一种nginx的负载均衡解决方案，通过分发和识别cookie，来使同一个客户端的请求落在同一台服务器上，默认标识名为route

1. 客户端首次发起访问请求，nginx接收后，发现请求头没有cookie，则以轮询方式将请求分发给后端服务器。
2. 后端服务器处理完请求，将响应数据返回给nginx。
3. 此时nginx生成带route的cookie，返回给客户端。route的值与后端服务器对应，可能是明文，也可能是md5、sha1等Hash值
4. 客户端接收请求，并保存带route的cookie。
5. 当客户端下一次发送请求时，会带上route，nginx根据接收到的cookie中的route值，转发给对应的后端服务器。

![1562398604770](D:\project\Java-BackEnd-Notes\doc\images\1562398604770.png)

无论如何刷新你都会发现这个 route 不会改变。

### 会话共享

既然会话保持和会话复制都不完美，那么我们为什么不把Session放在一个统一的地方呢，这样集群中的所有节点都在一个地方进行Session的存取就可以解决问题。

​    **Session存放到哪里？**

对于Session来说，肯定是频繁使用的，虽然你可以把它存放在数据库中，但是真正生产环境中我更推荐存放在性能更快的分布式KV数据中，例如：Memcached和Redis。

## nio 中 在 unix 函数用了什么？ epoll ？

select，poll，epoll都是IO多路复用的机制。

I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。

但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

### select()

`int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);`

select 描述符分为3类 writefds、readfds、和exceptfds

函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。

优点：select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。

缺点 ： select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024。



### 对于NIO 

执行selector.select()方法，poll0 函数把指向socket 句柄和事件的内存地址传给底层函数。

1. 如果之前没有发生事件，程序就阻塞在select处，当然不会一直阻塞，因为epoll在timeout时间内如果没有事件，也会返回。
2. 一旦有对应的事件发生，poll0方法就会返回。
3. 统计有事件发生的SelectionKey数量，并把符合条件发生事件的SelectionKey添加到selectedKeys哈希表中，提供给后续使用。

* 在早期的JDK1.4和1.5 update10版本之前，Selector基于select/poll模型实现
* 在JDK1.5 update10和linux core2.6以上版本，sun优化了Selctor的实现，底层使用epoll替换了select/poll。